# Bleualign

Bleualign是用于文本对齐的Python开源项目。本文使用C++重构。[GitHub传送门](https://github.com/rsennrich/Bleualign)

给定A 与 B语言原文，以及A的机器翻译后的结果(A-->B)、B的机器翻译后的结果(B-->A)。可以有一个翻译器翻译多个也可以多个翻译器同时翻译。通过这四个文件，找出A与B原文中，相关度最大的行对应关系，后期可能用于训练。

事前准备: 特定语种使用特定语种的分词器，按照空格进行分词。

Bleualign大致流程是：

- A原文 与B的译文一一计算bleu找到最优对。里面每个取交集。
- B原文 与A的译文一一计算bleu找到最优对。里面每个取交集。
- 两结果取交集

## 一 bleu计算

gram：在逐一分词之后，不仅仅考虑每一个词，还需要保证流畅性。考虑前后gram个分词的连续关系，将这些多个词作为整体考虑，gram越大越说明流畅性越高，这里gram为2。

遍历每行A原文与B译文。通过分词后，他们最大gram个数分词如果有重合，说明他们可能有关联，进行bleu计算。否则跳过。

首先**正向计算**A原文与译文B的bleu。

定义:

- A行中的分词数量$ T $(仅仅为单个分词)。
- B行中分词数量为$ R $（仅仅为单个分词）。

- 每个ngram可能会出现的最大分词数$ G $。

- 对应的每一行的ngram命中数为$ C $。(翻译中的ngram)。

计算A-->B的bleu值
$$
bleu_{A->B} = exp(\frac{\sum_{k = 1}^n(log(C_k) - log(G_k))}{n} + min(0,1-\frac{R}{T}))
$$
在反向计算$bleu_{B->A}$后，取调和平均数作为这两行的最终bleu
$$
bleu = \frac{2 * bleu_{A->B} * bleu_{B->A}}{bleu_{A->B} + bleu_{B->A}}
$$

## 二 DP找最优组合

对于A行对应的每一行B的bleu，只取前三个最大bleu列作为候选。使用动态规划算法，构建最大bleu的队列。

建立A行数 + 1，B行数 + 1的得分矩阵`matrix`，+1为了防止越界。建立A行数B行数的方向矩阵`pointers`，在遍历完周后原路返回找到最优配对。

`matrix`存储的是当前的最优分数，遍历所有AB的对应，如果对应存在并且当前得分+新得分高于原先最高得分，记录当前节点的`pointers`为match状态，否则根据情况判定。

当所有情况遍历完成后，逆向查找找到最优解。



## 三 修补缝隙

动态规划求解最优配对后，仅仅能得到一对一的对子，如果存在句子分割成多行的情况，也许能匹配上最大bleu的对子但并不是最好的解决方案，因此存在一对多和多对一的可能性。

>此例子为一行A对应着两行B
>
>A : （1）我今晚吃了一个黄色的苹果，苹果真的好吃。
>
>B : （1）我今晚吃了一个黄色的苹果
>
>	（2）苹果真的好吃

因为动态规划后的结果成对，依次遍历这些`pair`(A,B)，记录当前遍历的结果和上一次遍历的结果。若两结果均相邻则不存在缝隙，若有一个不相邻则会存在缝隙。在这里不会存在两方都不相邻的结果，如果都不相邻的话必定其中会有配对成功的，即使bleu微乎其微。

![](https://pic.imgdb.cn/item/613c546f44eaada739a583cf.png)

找到缝隙之后，考虑A列当前`pair`与上一次`pair`再加上所有缝隙的集合。在这个集合当中额外加入先前`pair`与先前`pair+1`、当前`pair`与当前`pair-1`的集合,B同理操作。

在这两个生成的集合中计算一一对应的bleu并且找到每一行的最大blue。判断在多对一的情况下bleu是否有提升，有的保留，没有遍历下一个。

## 四 结果取交集

A原文与每个B译文进行匹配之后会都会有一个集合$Set_{a->b}$。这些集合取交集。

B原文与每个A译文进行匹配之后会都会有一个集合$Set_{b->a}$。这些集合取交集。

最后将$Set_{a->b}$与$Set_{b->a}$再次取交集，就可以求解。

![](https://pic.imgdb.cn/item/613c546f44eaada739a583d3.png)